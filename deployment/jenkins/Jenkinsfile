pipeline {
    agent any
    
    environment {
        AWS_ACCOUNT_ID = '597088035400'
        AWS_REGION = 'eu-west-3'
        ECR_REPO_URL = '597088035400.dkr.ecr.eu-west-3.amazonaws.com/excellia'
        CLUSTER_NAME = 'excellia-eks-cluster'
        CLUSTER_ENDPOINT = 'https://F1DFB6A2A0D97186B6408CD13D101A75.gr7.eu-west-3.eks.amazonaws.com'
        CLUSTER_OIDC_ISSUER = 'https://oidc.eks.eu-west-3.amazonaws.com/id/F1DFB6A2A0D97186B6408CD13D101A75'
        CLUSTER_SG_ID = 'sg-0810f03f119a4ef58'
        SERVICES = 'discovery-service config-service gateway-service inscription-service messagerie-service notification-service gestion-bourse-candidature-service'
        FRONTEND_APP = 'Excellia_Frontend'
        KUBECONFIG = "${env.WORKSPACE}/.kube/config"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup Environment') {
            steps {
                withAWS(credentials: 'aws-credentials', region: "${AWS_REGION}") {
                    sh '''
                        # Setup AWS CLI explicitly
                        mkdir -p ~/.aws
                        aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
                        aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
                        aws configure set region "${AWS_REGION}"
                        
                        # Verify AWS credentials
                        aws sts get-caller-identity
                        
                        # Installer ou mettre à jour les outils nécessaires
                        ansible-playbook -i localhost, deployment/ansible/setup-tools.yml -c local -b
                        
                        # Authentification à ECR
                        aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${ECR_REPO_URL}"
                        
                        # Ensure .kube directory exists
                        mkdir -p "${WORKSPACE}/.kube"
                        
                        # Configurer kubeconfig pour accéder au cluster EKS
                        export KUBECONFIG="${KUBECONFIG}"
                        aws eks update-kubeconfig --name "${CLUSTER_NAME}" --region "${AWS_REGION}" --kubeconfig "${KUBECONFIG}"
                        
                        # Test the connection to ensure credentials are working
                        kubectl --kubeconfig="${KUBECONFIG}" get svc
                    '''
                }
            }
        }
        
        stage('Build utilitiesService') {
            steps {
                dir('Excellia_bourse/utilitiesService') {
                    sh 'mvn clean install -DskipTests'
                    echo 'utilitiesService built and installed in local Maven repository'
                }
            }
        }
        
        stage('Build and Push Backend Images') {
            steps {
                script {
                    def servicesList = env.SERVICES.split(' ')
                    servicesList.each { service ->
                        dir("Excellia_bourse/${service}") {
                            sh 'mvn clean package -DskipTests'
                            
                            def imageTag = "${ECR_REPO_URL}:${service}-${BUILD_NUMBER}"
                            
                            sh """
                                docker build -t ${imageTag} .
                                docker push ${imageTag}
                                echo "Image ${imageTag} pushed to ECR"
                            """
                        }
                    }
                }
            }
        }
        
        stage('Build and Push Frontend Image') {
            steps {
                dir("${FRONTEND_APP}") {
                    script {
                        def frontendImageTag = "${ECR_REPO_URL}:frontend-${BUILD_NUMBER}"
                        
                        sh """
                            docker build -t ${frontendImageTag} .
                            docker push ${frontendImageTag}
                            echo "Frontend image ${frontendImageTag} pushed to ECR"
                        """
                    }
                }
            }
        }
        
        stage('Generate Kubernetes Manifests') {
            steps {
                sh '''
                    mkdir -p kubernetes-manifests
                    
                    # Générer les ConfigMaps, Secrets, etc. à partir des templates
                    python3 deployment/scripts/generate_k8s_manifests.py \
                        --build-number "${BUILD_NUMBER}" \
                        --ecr-repo "${ECR_REPO_URL}" \
                        --output-dir kubernetes-manifests
                '''
                
                archiveArtifacts artifacts: 'kubernetes-manifests/**/*', fingerprint: true
            }
        }
        
        stage('Deploy to EKS') {
            steps {
                withAWS(credentials: 'aws-credentials', region: "${AWS_REGION}") {
                    sh '''
                        export KUBECONFIG="${KUBECONFIG}"
                        
                        # Refresh AWS credentials before kubectl operations
                        export AWS_ACCESS_KEY_ID=$(aws configure get aws_access_key_id)
                        export AWS_SECRET_ACCESS_KEY=$(aws configure get aws_secret_access_key)
                        
                        # Vérifier la connexion au cluster
                        kubectl get nodes
                        
                        # Apply manifests
                        kubectl apply -f kubernetes-manifests/configmaps/
                    '''
                }
            }
        }
        
        stage('Validate Deployment') {
            steps {
                withAWS(credentials: 'aws-credentials', region: "${AWS_REGION}") {
                    sh '''
                        export KUBECONFIG="${KUBECONFIG}"
                        
                        # Vérifier que tous les pods sont en running
                        kubectl wait --for=condition=Ready pods --all -n excellia --timeout=300s
                        
                        # Récupérer l'URL du service de frontend
                        FRONTEND_URL=$(kubectl get svc frontend -n excellia -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        
                        echo "Application déployée avec succès!"
                        echo "Frontend accessible à l'adresse: http://${FRONTEND_URL}"
                        echo "Cluster endpoint: ${CLUSTER_ENDPOINT}"
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline exécuté avec succès! L\'application est déployée sur EKS.'
            sh '''
                # Placeholder pour notifications de succès (Slack, Teams, etc.)
            '''
        }
        failure {
            echo 'Le pipeline a échoué. Vérifiez les logs pour plus de détails.'
            sh '''
                # Placeholder pour notifications d'échec
            '''
        }
        always {
            sh 'docker system prune -f'
        }
    }
}